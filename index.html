<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Rocket Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: white;
        }
        canvas {
            display: block;
            background-color: #001;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0069d9;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div>Altitude: <span id="altitude">0</span> m</div>
            <div>Velocity: <span id="velocity">0</span> m/s</div>
            <div>Fuel: <span id="fuel">100</span>%</div>
            <div>Status: <span id="status">Ready</span></div>
        </div>
        <div id="controls">
            Controls: Use Arrow Keys (↑ thrust, ← → rotate)
        </div>
    </div>

    <script>
        // Game constants
        const GRAVITY = 0.05;
        const THRUST_POWER = 0.08;
        const ROTATION_SPEED = 0.08;
        const DRAG_COEFFICIENT = 0.005;
        const FUEL_CONSUMPTION = 0.4;
        const LANDING_SPEED_THRESHOLD = 1.5;
        const LANDING_ANGLE_THRESHOLD = 0.3;
        
        // Game variables
        let canvas, ctx;
        let rocket = {
            x: 0,
            y: 0,
            width: 10,
            height: 30,
            vx: 0,
            vy: 0,
            angle: 0, // in radians, 0 = pointing up
            fuel: 100,
            thrustOn: false,
            crashed: false,
            landed: false
        };
        let gameStarted = false;
        let stars = [];
        let terrain = [];
        let landingPads = [];
        let keysPressed = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false
        };
        let gameStats = {
            altitude: 0,
            velocity: 0,
            fuelRemaining: 100,
            status: 'Ready'
        };
        
        // Initialize the game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size to window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Generate stars
            generateStars(200);
            
            // Generate terrain
            generateTerrain();
            
            // Place the rocket on the ground
            placeRocketOnGround();
            
            // Start the game loop
            gameLoop();
            
            // Add event listeners
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', handleResize);
        }
        
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateTerrain(); // Regenerate terrain for new size
            placeRocketOnGround(); // Reposition rocket
        }
        
        function generateStars(count) {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
        }
        
        function generateTerrain() {
            terrain = [];
            landingPads = [];
            
            // Generate a rough terrain with some landing pads
            const segments = 40;
            const segmentWidth = canvas.width / segments;
            
            let prevHeight = Math.random() * 100 + (canvas.height - 200);
            
            for (let i = 0; i <= segments; i++) {
                let x = i * segmentWidth;
                let y;
                
                // Add landing pads at certain intervals
                if (i % 10 === 5) {
                    const padWidth = 3;
                    const padHeight = Math.random() * 100 + (canvas.height - 200);
                    
                    // Add left edge of pad
                    if (i > 0) {
                        terrain.push({ x: x - segmentWidth, y: prevHeight });
                    }
                    
                    // Add the pad (flat)
                    for (let j = 0; j < padWidth; j++) {
                        terrain.push({ x: x + (j * segmentWidth), y: padHeight });
                    }
                    
                    // Record landing pad position
                    landingPads.push({
                        x: x + segmentWidth,
                        y: padHeight,
                        width: padWidth * segmentWidth
                    });
                    
                    prevHeight = padHeight;
                    i += padWidth - 1; // Skip ahead for pad width
                } else {
                    // Regular terrain
                    y = prevHeight + (Math.random() * 60 - 30);
                    
                    // Keep terrain within reasonable bounds
                    y = Math.max(canvas.height - 500, Math.min(canvas.height - 50, y));
                    
                    terrain.push({ x, y });
                    prevHeight = y;
                }
            }
        }
        
        function placeRocketOnGround() {
            // Place the rocket on the first landing pad
            if (landingPads.length > 0) {
                const pad = landingPads[0];
                rocket.x = pad.x;
                rocket.y = pad.y - rocket.height / 2;
            } else {
                // Fall back to placing it on regular terrain
                rocket.x = canvas.width / 4;
                const groundHeight = getGroundHeightAt(rocket.x);
                rocket.y = groundHeight - rocket.height / 2;
            }
            
            // Reset rocket state
            rocket.vx = 0;
            rocket.vy = 0;
            rocket.angle = 0;
            rocket.fuel = 100;
            rocket.thrustOn = false;
            rocket.crashed = false;
            rocket.landed = false;
            
            gameStarted = true;
            
            updateHUD();
        }
        
        function getGroundHeightAt(x) {
            if (terrain.length < 2) return canvas.height;
            
            // Find the terrain segments that contain x
            for (let i = 0; i < terrain.length - 1; i++) {
                if (x >= terrain[i].x && x < terrain[i+1].x) {
                    // Linear interpolation between points
                    const t = (x - terrain[i].x) / (terrain[i+1].x - terrain[i].x);
                    return terrain[i].y + t * (terrain[i+1].y - terrain[i].y);
                }
            }
            
            return canvas.height;
        }
        
        function isOnLandingPad(x) {
            for (const pad of landingPads) {
                if (x >= pad.x - pad.width/2 && x <= pad.x + pad.width/2) {
                    return pad;
                }
            }
            return null;
        }
        
        function handleKeyDown(e) {
            if (keysPressed.hasOwnProperty(e.code)) {
                keysPressed[e.code] = true;
                
                // Prevent scrolling with arrow keys
                if (e.code === 'ArrowUp' || e.code === 'ArrowDown' || 
                    e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                    e.preventDefault();
                }
            }
            
            // Reset with R key
            if (e.code === 'KeyR') {
                placeRocketOnGround();
            }
        }
        
        function handleKeyUp(e) {
            if (keysPressed.hasOwnProperty(e.code)) {
                keysPressed[e.code] = false;
            }
        }
        
        function updateRocket() {
            if (rocket.crashed || rocket.landed) return;
            
            // Thrust control
            rocket.thrustOn = keysPressed.ArrowUp && rocket.fuel > 0;
            
            // Apply rotation
            if (keysPressed.ArrowLeft) {
                rocket.angle -= ROTATION_SPEED;
            }
            if (keysPressed.ArrowRight) {
                rocket.angle += ROTATION_SPEED;
            }
            
            // Apply thrust if thrust is on
            if (rocket.thrustOn) {
                // Calculate thrust components
                const thrustX = THRUST_POWER * Math.sin(rocket.angle);
                const thrustY = -THRUST_POWER * Math.cos(rocket.angle);
                
                rocket.vx += thrustX;
                rocket.vy += thrustY;
                
                // Consume fuel
                rocket.fuel = Math.max(0, rocket.fuel - FUEL_CONSUMPTION);
            }
            
            // Apply gravity
            rocket.vy += GRAVITY;
            
            // Apply drag (simple model)
            rocket.vx *= (1 - DRAG_COEFFICIENT);
            rocket.vy *= (1 - DRAG_COEFFICIENT);
            
            // Update position
            rocket.x += rocket.vx;
            rocket.y += rocket.vy;
            
            // Bounce off walls
            if (rocket.x < 0) {
                rocket.x = 0;
                rocket.vx *= -0.5; // Bounce with energy loss
            } else if (rocket.x > canvas.width) {
                rocket.x = canvas.width;
                rocket.vx *= -0.5;
            }
            
            // Check for collision with ground
            const groundHeight = getGroundHeightAt(rocket.x);
            const pad = isOnLandingPad(rocket.x);
            
            if (rocket.y + rocket.height/2 >= groundHeight) {
                // We've hit the ground, check if landing or crash
                const velocity = Math.sqrt(rocket.vx * rocket.vx + rocket.vy * rocket.vy);
                
                if (pad && 
                    velocity < LANDING_SPEED_THRESHOLD && 
                    Math.abs(rocket.angle) < LANDING_ANGLE_THRESHOLD) {
                    // Successful landing
                    rocket.y = groundHeight - rocket.height/2;
                    rocket.vx = 0;
                    rocket.vy = 0;
                    rocket.landed = true;
                    gameStats.status = "Landed safely!";
                } else {
                    // Crash
                    rocket.crashed = true;
                    gameStats.status = "Crashed!";
                }
            }
            
            // Update game stats
            gameStats.altitude = Math.max(0, Math.floor(groundHeight - (rocket.y + rocket.height/2)));
            gameStats.velocity = Math.sqrt(rocket.vx * rocket.vx + rocket.vy * rocket.vy).toFixed(2);
            gameStats.fuelRemaining = Math.floor(rocket.fuel);
            
            updateHUD();
        }
        
        function updateHUD() {
            document.getElementById('altitude').textContent = gameStats.altitude;
            document.getElementById('velocity').textContent = gameStats.velocity;
            document.getElementById('fuel').textContent = gameStats.fuelRemaining;
            document.getElementById('status').textContent = gameStats.status;
        }
        
        function drawStars() {
            ctx.fillStyle = 'white';
            for (const star of stars) {
                ctx.globalAlpha = star.opacity;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function drawTerrain() {
            // Draw terrain background
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (const point of terrain) {
                ctx.lineTo(point.x, point.y);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Draw terrain outline
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(terrain[0].x, terrain[0].y);
            
            for (let i = 1; i < terrain.length; i++) {
                ctx.lineTo(terrain[i].x, terrain[i].y);
            }
            
            ctx.stroke();
            
            // Draw landing pads
            ctx.fillStyle = '#0a0';
            for (const pad of landingPads) {
                ctx.fillRect(pad.x - pad.width/2, pad.y - 5, pad.width, 5);
            }
        }
        
        function drawRocket() {
            ctx.save();
            ctx.translate(rocket.x, rocket.y);
            ctx.rotate(rocket.angle);
            
            // Draw rocket body
            if (rocket.crashed) {
                // Draw crash state
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                // Draw some irregular shapes to look like debris
                for (let i = 0; i < 10; i++) {
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.random() * 20 - 10, Math.random() * 20 - 10);
                }
                ctx.fill();
            } else {
                // Draw normal rocket
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(0, -rocket.height/2);
                ctx.lineTo(-rocket.width/2, rocket.height/2 - 5);
                ctx.lineTo(rocket.width/2, rocket.height/2 - 5);
                ctx.closePath();
                ctx.fill();
                
                // Draw fins
                ctx.fillStyle = '#f44';
                ctx.beginPath();
                ctx.moveTo(-rocket.width/2, rocket.height/2 - 5);
                ctx.lineTo(-rocket.width, rocket.height/2);
                ctx.lineTo(-rocket.width/2, rocket.height/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(rocket.width/2, rocket.height/2 - 5);
                ctx.lineTo(rocket.width, rocket.height/2);
                ctx.lineTo(rocket.width/2, rocket.height/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw thrust fire if thrusters are on
                if (rocket.thrustOn) {
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(-rocket.width/4, rocket.height/2);
                    ctx.lineTo(0, rocket.height/2 + 10 + Math.random() * 5);
                    ctx.lineTo(rocket.width/4, rocket.height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#f40';
                    ctx.beginPath();
                    ctx.moveTo(-rocket.width/6, rocket.height/2);
                    ctx.lineTo(0, rocket.height/2 + 5 + Math.random() * 5);
                    ctx.lineTo(rocket.width/6, rocket.height/2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawGameOver() {
            if (rocket.crashed || rocket.landed) {
                const message = rocket.crashed ? 'CRASHED!' : 'LANDED SAFELY!';
                const subMessage = rocket.crashed ? 'Press R to try again' : 'Press R for new mission';
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 60, 300, 120);
                
                ctx.fillStyle = rocket.crashed ? '#f55' : '#5f5';
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(message, canvas.width/2, canvas.height/2 - 20);
                
                ctx.fillStyle = '#fff';
                ctx.font = '18px Arial';
                ctx.fillText(subMessage, canvas.width/2, canvas.height/2 + 20);
            }
        }
        
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawStars();
            
            // Draw terrain
            drawTerrain();
            
            // Update and draw rocket
            if (gameStarted) {
                updateRocket();
            }
            drawRocket();
            
            // Draw game over message if needed
            drawGameOver();
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game when the page loads
        window.onload = init;
    </script>
</body>
</html>
